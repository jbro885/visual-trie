{"version":3,"sources":["Trie.js","App.js","serviceWorker.js","index.js"],"names":["Trie","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","root","id","dict","renderedNodes","inputWord","word","_this2","currNode","letterIter","split","entries","letterResult","next","_loop","_letterResult$value","slicedToArray","value","i","letter","foundLetter","childIter","childResult","_loop2","_childResult$value","j","node","length","setState","done","newNode","push","updateDict","parent","setTimeout","renderNewNode","words","_this3","prefix","arguments","undefined","forEach","child","newPrefix","findWordsFromNode","level","_this4","newNumOnLevel","counter","availableSpace","keys","key","item","console","log","text","renderedParent","circleX","circleY","transition","duration","attr","line","color","d3","refs","svg","append","lower","circle","style","childLines","addToRenderedNodes","CANVAS_WIDTH","_this5","error","baseNode","e","preventDefault","addWord","_this6","react_default","a","createElement","width","height","ref","styles","onSubmit","handleSubmit","onChange","target","type","placeholder","Component","backgroundColor","App","className","GithubCorner_default","octoColor","bannerColor","href","marginTop","Trie_Trie","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.177db53c.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport * as d3 from 'd3'\n\nconst CIRCLE_RADIUS = 20;\nconst VERTICAL_SPACING = 70;\nconst CANVAS_WIDTH = 1000;\n\nexport default class Trie extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      // Root node, string is false because and empty string will change to null\n      root: [false, 0, false],\n      // Incrementing unique id\n      id: 1,\n      // Array representing dict which will implement trie\n      dict: [],\n      // Arrary representing the rendered nodes\n      renderedNodes: [],\n      // The current word inside of the text input\n      inputWord: '',\n    };\n    // Inserting the root node into the dict\n    this.state.dict[this.state.root] = [];\n  }\n\n  addWord(word) {\n    let prevNode;\n    let currNode = this.state.root;    \n    \n    const letterIter = word.split('').entries();\n    let letterResult = letterIter.next();\n          \n    while (!letterResult.done) {\n\n      const [i, letter] = letterResult.value;\n      let foundLetter = false;\n      const childIter = this.state.dict[currNode].entries();\n      let childResult = childIter.next();\n      \n      while (!childResult.done) {\n\n        const [j, node] = childResult.value;\n        if (node[0] === letter) {\n          if (i === word.length - 1 && !node[2]) {\n            /* eslint-disable-next-line no-loop-func*/\n            this.setState((state) => {\n              // TODO: Update existing node to be truncating node in visualizer\n              state.dict[currNode][j] = [currNode[0], currNode[1], true];\n              return { dict: state.dict }\n            })\n            // this.state.dict[currNode][j] = [currNode[0], currNode[1], true];\n            prevNode = currNode;\n            currNode = this.state.dict[currNode][j];\n            \n            \n            /* eslint-disable-next-line no-loop-func*/\n            this.setState((state) => {\n              state.dict[currNode] = this.state.dict[node];\n              return { dict: state.dict };\n            })\n            // this.state.dict[currNode] = this.state.dict[node];\n            this.setState((state) => {\n              delete state.dict[node];\n              return { dict: state.dict }\n            })\n            // delete this.state.dict[node];\n          } else {\n            prevNode = currNode;\n            currNode = node;\n          }\n          foundLetter = true;\n          break;\n        }\n        childResult = childIter.next();\n      }\n      if (!foundLetter) {\n        let newNode;\n        if (i === word.length - 1) {\n          newNode = [letter, this.state.id, true];\n        } else {\n          newNode = [letter, this.state.id, false];\n        }\n        \n        const updateId = (state) => {\n          state.id += 1\n\n          return { id: state.id }\n        }\n        this.setState(updateId(this.state));\n\n        \n        /* eslint-disable-next-line no-loop-func*/\n        const updateDict = (state) => {\n          state.dict[currNode].push(newNode)\n          state.dict[newNode] = [];\n          return { dict: state.dict } \n        }\n        this.setState(updateDict(this.state));\n        \n        // TODO: Set delay to this\n        const parent = currNode;\n        setTimeout(() => this.renderNewNode(parent, newNode, i + 1), 500 * (i + 1))\n\n\n        prevNode = currNode;\n        currNode = newNode;\n      }\n      letterResult = letterIter.next();\n    }\n  }\n\n  findWordsFromNode(words, prefix = '', node = this.state.root) {\n    if (node[2]) {\n      words.push(prefix);\n    }\n\n    this.state.dict[node].forEach((child) => {\n      const newPrefix = prefix + child[0];\n      this.findWordsFromNode(words, newPrefix, child);\n    });\n  }\n\n  renderNewNode(parent, node, level) {\n    // Save the coupling of the circle and text to an array\n    //          this will allow me to alter the rendering of the\n    //          circles after intial rendering (allowing for shifting)\n    // Save the parent circle, this will allow for drawing the\n    //          line from parent to child. This needs to be svg and\n    //          not the node data. This is because the x and y will\n    //          change later if more nodes at the height are rendered.\n    //          BUT, what if the previous node wasn't just created?\n    //          How do we pass through the circle? We don't just send\n    //          the node, when inserting the rendered objects into \n    //          renderedNodes also insert the nodes themselves so\n    //          when we go to write the line you can search for the\n    //          node in the renderedNodes collection.\n    // Maybe make a d3 render method. At render time check \n    //          to see if there are any other nodes on the level.\n    //          if there are, change the rendering of the other nodes\n    //          then insert the new node\n    // When rendering the nodes on a level, consider the\n    //          entire level as 100% width. Once implemented consider\n    //          switching to giving each parent node a specified \n    //          children width.  Then use that as 100%\n    \n    let newNumOnLevel = 1\n    let counter = 1\n    let availableSpace = (CANVAS_WIDTH) / (newNumOnLevel + 1)        \n    if(this.state.renderedNodes[level]){          \n      newNumOnLevel += Object.keys(this.state.renderedNodes[level]).length\n      availableSpace = (CANVAS_WIDTH) / (newNumOnLevel + 1)\n      const updateRenderedNodes = (state) =>{\n        Object.keys(state.renderedNodes[level]).forEach((key) => {\n          const item = state.renderedNodes[level][key]\n          console.log('rerendering:', item[2].text());\n          console.log('counter:', counter);\n          \n\n          const renderedParent = this.state.renderedNodes[level - 1][item[5]][1]\n          \n          const circleX = availableSpace * counter\n          const circleY = VERTICAL_SPACING * (level + 1)\n\n          // TODO: To fix the line, probably have to save the child node to rendered parent object\n          //          Then when rerendering change the the x1 of the child node's line\n          item[1].transition().duration(500)\n            .attr(\"cx\", circleX)\n            .attr(\"cy\", circleY)\n          item[2].transition().duration(500)\n            .attr(\"x\", availableSpace * counter - 10 )\n            .attr(\"y\", VERTICAL_SPACING * (level + 1))\n\n          item[3].transition().duration(500)\n            .attr(\"x1\", renderedParent.attr('cx'))\n            .attr(\"y1\", renderedParent.attr('cy'))\n            .attr(\"x2\", circleX)\n            .attr(\"y2\", circleY)\n\n          item[4].forEach((line) => {\n            line.transition().duration(500)\n              .attr(\"x1\", circleX)\n              .attr(\"y1\", circleY);\n          })\n\n          counter += 1\n        })\n        return { renderedNodes: state.renderedNodes }\n      }\n      this.setState(updateRenderedNodes(this.state))\n    }\n\n    let color = \"#f3f3f3ff\"\n    if (node[2]) {\n      color = \"#fce5cdff\"\n    }\n\n    console.log('creating:', node[0]);;\n    \n\n    const renderedParent = this.state.renderedNodes[level - 1][parent][1]\n\n    const circleX = availableSpace * counter \n    const circleY = VERTICAL_SPACING * (level + 1)\n\n    let line = d3.select(this.refs.svg).append(\"line\")\n      .attr(\"x1\", renderedParent.attr('cx')).attr(\"y1\", renderedParent.attr('cy'))\n      .attr(\"x2\", renderedParent.attr('cx')).attr(\"y2\", renderedParent.attr('cy'))\n      .attr(\"stroke\", \"black\")\n      .lower()\n\n    line.transition().duration(500)\n    .attr(\"x2\", circleX).attr(\"y2\", circleY)\n      \n\n    let circle = d3.select(this.refs.svg).append(\"circle\")\n      .attr(\"cx\", circleX)\n      .attr(\"cy\", circleY)\n      .attr(\"r\", CIRCLE_RADIUS)\n      .style(\"fill\", color)\n    \n    let text = d3.select(this.refs.svg).append(\"text\")\n      .attr(\"x\", availableSpace * counter - 10)\n      .attr(\"y\", 5 + VERTICAL_SPACING * (level + 1))\n      .text(\"'\" + node[0] + \"'\")\n      .style(\"font-size\", \"25px\")\n      .style(\"fill\", \"black\")\n\n    let childLines = []\n\n    this.state.renderedNodes[level - 1][parent][4].push(line);\n\n    \n    const addToRenderedNodes = ((state) => {\n      if(state.renderedNodes[level]){\n        state.renderedNodes[level][node] =[node, circle, text, line, childLines, parent]\n      } else {\n        state.renderedNodes[level] = []\n        state.renderedNodes[level][node] = [node, circle, text, line, childLines, parent]\n      }\n      return {renderedNodes: state.renderedNodes};\n    });\n\n    this.setState(addToRenderedNodes(this.state));\n  }\n\n  componentDidMount() {\n    const circle = d3.select(this.refs.svg).append(\"circle\")\n      .attr(\"cx\", CANVAS_WIDTH/2 )\n      .attr(\"cy\", 55)\n      .attr(\"r\", CIRCLE_RADIUS)\n      .style(\"fill\", \"#f3f3f3ff\");\n    const text = d3.select(this.refs.svg).append(\"text\")\n      .attr(\"x\", CANVAS_WIDTH/2 - 5)\n      .attr(\"y\", 55 )\n      .text(\"''\")\n      .style(\"font-size\", \"25px\")\n      .style(\"fill\", \"black\")\n    const childLines = [];\n    const pushRootToRenderedNodes = (state) => {\n      state.renderedNodes[0] = []\n      state.renderedNodes[0][[false, 0, false]] = [[false, 0, false], circle, text, null, childLines, null]\n    \n      \n      return {renderedNodes: state.renderedNodes}\n    }\n    this.setState(pushRootToRenderedNodes(this.state))\n  }\n\n  autocomplete(prefix) {\n    const words = [];\n    let currNode = this.state.root;\n    console.log(\"currNode\", currNode);\n\n    prefix.split('').forEach((letter) => {\n      let foundLetter = false;\n\n      this.state.dict[currNode].forEach((node) => {\n        if (node[0] === letter && !foundLetter) {\n          currNode = node;\n          foundLetter = true;\n        }\n      });\n      if (!foundLetter) {\n        console.error('PREFIX NOT IN TRIE');\n        return words; \n      }\n    });\n    const baseNode = currNode;\n    this.findWordsFromNode(words, prefix, baseNode);\n    return words;\n  }\n\n  handleSubmit(e) {\n    e.preventDefault()\n\n    if (this.state.inputWord.length > 0) {\n      this.addWord(this.state.inputWord)\n      this.setState({inputWord: ''})\n    }\n  }\n  \n  render() {\n    console.log(\"render\");\n    \n    return (\n      <div>\n      <svg width={CANVAS_WIDTH} height=\"800\" id=\"trie\" ref=\"svg\" style={styles}>\n      </svg>\n      <form onSubmit={e => this.handleSubmit(e)}>\n        <input value={this.state.inputWord} onChange={e => this.setState({ inputWord: e.target.value })}\n        type=\"text\" placeholder=\"New word\"/>\n        <button type=\"submit\">Add Word</button>\n      </form>\n      </div>\n    )\n  }\n}\n\nconst styles = {\n  backgroundColor: '#ffffff',\n}\n","/* eslint-disable react/jsx-filename-extension */\nimport React, { Component } from 'react';\nimport GithubCorner from 'react-github-corner';\n\nimport Trie from './Trie';\nimport './App.css';\n\n// eslint-disable-next-line react/prefer-stateless-function\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <GithubCorner octoColor=\"#444151\" bannerColor=\"#ffffff\" href=\"https://github.com/seve/visual-trie\" />\n        <div className=\"canvas\" style={{ marginTop: '32px' }}>\n          <Trie />\n        </div>\n      </div>\n    );\n  }\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}